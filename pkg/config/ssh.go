package config

import (
	"bytes"
	"text/template"

	"github.com/pkg/errors"
)

const (
	// small template - just inline so we don't have to deal with packing it to binary
	sshConfigTemplate = `
# Generated by blessclient
{{ range $index, $bastion := . }}
Match OriginalHost $bastion.Pattern exec "blessclient run"
  IdentityFile $bastion.IdentityFile
  User $bastion.User

Host $bastion.Pattern
  User $bastion.User

{{ range $index, $host := $bastion.Hosts }}

Host $host.Pattern
  ProxyJump $bastion.Pattern
  User $host.User

{{ end }}

{{ end }}
#
`
)

// SSHConfig is an SSH config
// We make some assumptions here around the structure of the machines
// A bastion is internet accessible and can be used to reach other machines
type SSHConfig struct {
	Bastions []Bastion `yaml:"bastions"`
}

// String generates the ssh config string
func (s *SSHConfig) String() (string, error) {
	t, err := template.New("ssh_config").Parse(sshConfigTemplate)
	if err != nil {
		return "", errors.Wrap(err, "Could not parse ssh_config template")
	}

	b := bytes.NewBuffer(nil)
	err = t.Execute(b, s)
	if err != nil {
		return "", errors.Wrap(err, "Could not templetize ssh_config")
	}
	return b.String(), nil
}

// Bastion is an internet accessibly server used to "jump" to other servers
type Bastion struct {
	Host `yaml:",inline"`

	Hosts        []Host `yaml:"hosts"`
	IdentityFile string `yaml:"identity_file"`
	User         string `yaml:"user"`
}

// Host represents a Host block in an ssh config
type Host struct {
	Pattern string `yaml:"pattern"`
}
